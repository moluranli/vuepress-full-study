# JVM学习

视频学习地址:[https://www.bilibili.com/video/BV1yE411Z7AP?vd_source=737bc72ddc8b0e9190302e61a877a9d8](https://www.bilibili.com/video/BV1yE411Z7AP?p=1&vd_source=737bc72ddc8b0e9190302e61a877a9d8)



## JVM概览

### 1. JVM定义

JVM是java **Virtual Machine java**的运行时环境(**Java 字节码的运行环境**)

### 2. JVM好处

- **一次**编写,**到处**运行
- **自动内存管理**,**垃圾回收机制**
- **数组越界检查**(如果没有可能会更改其他地方的数据)
- 多态



![image-20220718093536862](https://s2.loli.net/2022/07/18/5yPwYSsg7GiFCEQ.png)



### 3. JVM的组成

![image-20220718093905544](https://s2.loli.net/2022/07/18/1qtopOh3JITkH7z.png)

1. 程序编译成java的二进制字节码后经过ClassLoader类加载器加载到JVM中运行
2. 程序中的类放在方法区,类创建的实例和对象放在堆中,对象调用方法时用到虚拟机栈,程序计数器和本地方法栈
3. 方法执行时,每行代码由Interpreter解释器逐行执行,方法中频繁调用的代码使用即时编译器进行优化,
4. GC会对堆中不再应用的对象进行垃圾回收
5. 本地方法接口是操作系统中的一些方法



## 程序计数器

### 1. 程序计数器作用

程序计数器就是在执行每条语句的时候记录下一条指令的地址,物理上是通过寄存器实现的

![image-20220718102440409](https://s2.loli.net/2022/07/18/rEkPq1HKTMbc7Xf.png)



### 2. 程序计数器特点

1. 线程**私有**,每**一个线程**都有一个**属于自己**的**独立计数器**
2. 唯一一个**不会出现内存溢出**问题(Java虚拟机规范)



## 虚拟机栈

### 1. 虚拟机栈的定义

1. 每一个**线程运行时需要的内存空间**,就是一个虚拟机栈
2. 每个栈中有多个**栈帧**,代表**每个方法所需要的内存**,,栈帧进入时根据方法调用,如a方法中调用了b方法,那么a先进栈,b再进栈
3. 每**一个线程**只能有**一个活动栈帧**,代表当前**线程执行的方法**



### 2. 虚拟机栈相关问题

#### 1. 垃圾回收是否涉及虚拟机栈

垃圾回收不涉及虚拟机栈,因为虚拟机栈总的方法每次**出栈后自动回收**了,不需要调用垃圾回收机制



#### 2. 虚拟机栈分配内存是不是越大越好

不是,因为物理空间的大小是一定的,如果为一个线程分配很大的栈内存的话,那么其他的线程所能分配的内存就会变小,那么,**线程就会变少.**



#### 3.方法区中的局部变量会不会有线程安全问题

不会有线程安全问题,因为每一个线程使用独立的虚拟机栈,同时方法区中的局部变量**不能逃离方法的作用范围**



### 3.线程诊断

#### 1. CPU占用较高

[JDK工具:jstack命令](https://www.bilibili.com/video/BV1yE411Z7AP?p=14&spm_id_from=pageDriver&vd_source=737bc72ddc8b0e9190302e61a877a9d8)



#### 2. 无法得出结果

比如进程死锁:[jstack命令](https://www.bilibili.com/video/BV1yE411Z7AP?p=15&spm_id_from=pageDriver&vd_source=737bc72ddc8b0e9190302e61a877a9d8)



## 本地方法栈

本地方法栈就是为**本地方法**分配一个内存空间,**本地方法**就是操作系统的方法,有C,C++实现,在Java代码中是**native关键字**修饰,比如:

```java
protected native Object clone() throws CloneNotSupportedException;
```



## 堆

### 1. 堆的定义

每次**创建对象**都会使用堆内存,通过**new**



### 2. 堆的特点

- **堆内存**是**线程共享**的,所有要考虑线程安全问题
- 堆会使用**垃圾回收机制**



### 3. 堆内存溢出

例如:每次**new**一个对象,同时对象**一直被引用**,比如一直放在ArrayList当中,会造成堆内存占满,造成内存溢出

```java
java.lang.OutOfMemoryError: Java Heap space//堆内存溢出
```

使用`-Xmx8m`控制堆内存大小



### 4. 堆内存诊断工具

**jps,jmap,jconsole,jvirsualVM**

[jmap等](https://www.bilibili.com/video/BV1yE411Z7AP?p=19&vd_source=737bc72ddc8b0e9190302e61a877a9d8)



## 方法区

![image-20220720161550163](https://s2.loli.net/2022/07/20/AFCWlf1k8hdVytq.png)

### 1. 定义

JVM 方法区. 方法区与Java堆一样，是各个**线程共享**的内存区域，它用于**存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**,主要存储一些**类的数据**。

- **JDK1.8之前**,把方法区称作**永久代**
- **JDK1.8之后**,把方法区称作**元空间**,并把元空间放在**本地内存中**,方法区总的**StringTable**移到堆中.



### 2. 方法区的内存溢出问题

![image-20220720162918437](https://s2.loli.net/2022/07/20/dQpJtkZNwr1gf2W.png)

**结果**

![image-20220720163005984](https://s2.loli.net/2022/07/20/KnqEAUbBro1xHWP.png)*



### 3.StringTable 字符串常量池

**存储的是指向String对象的索引**，**真实对象**还是存储在**堆中**



