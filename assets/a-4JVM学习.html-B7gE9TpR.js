import{_ as n,c as e,d as s,o as l}from"./app-2M81OUT1.js";const r={};function t(i,a){return l(),e("div",null,a[0]||(a[0]=[s(`<h1 id="jvm学习" tabindex="-1"><a class="header-anchor" href="#jvm学习"><span>JVM学习</span></a></h1><p>视频学习地址:<a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=1&amp;vd_source=737bc72ddc8b0e9190302e61a877a9d8" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1yE411Z7AP?vd_source=737bc72ddc8b0e9190302e61a877a9d8</a></p><h2 id="jvm概览" tabindex="-1"><a class="header-anchor" href="#jvm概览"><span>JVM概览</span></a></h2><h3 id="_1-jvm定义" tabindex="-1"><a class="header-anchor" href="#_1-jvm定义"><span>1. JVM定义</span></a></h3><p>JVM是java <strong>Virtual Machine java</strong>的运行时环境(<strong>Java 字节码的运行环境</strong>)</p><h3 id="_2-jvm好处" tabindex="-1"><a class="header-anchor" href="#_2-jvm好处"><span>2. JVM好处</span></a></h3><ul><li><strong>一次</strong>编写,<strong>到处</strong>运行</li><li><strong>自动内存管理</strong>,<strong>垃圾回收机制</strong></li><li><strong>数组越界检查</strong>(如果没有可能会更改其他地方的数据)</li><li>多态</li></ul><p><img src="https://s2.loli.net/2022/07/18/5yPwYSsg7GiFCEQ.png" alt="image-20220718093536862"></p><h3 id="_3-jvm的组成" tabindex="-1"><a class="header-anchor" href="#_3-jvm的组成"><span>3. JVM的组成</span></a></h3><p><img src="https://s2.loli.net/2022/07/18/1qtopOh3JITkH7z.png" alt="image-20220718093905544"></p><ol><li>程序编译成java的二进制字节码后经过ClassLoader类加载器加载到JVM中运行</li><li>程序中的类放在方法区,类创建的实例和对象放在堆中,对象调用方法时用到虚拟机栈,程序计数器和本地方法栈</li><li>方法执行时,每行代码由Interpreter解释器逐行执行,方法中频繁调用的代码使用即时编译器进行优化,</li><li>GC会对堆中不再应用的对象进行垃圾回收</li><li>本地方法接口是操作系统中的一些方法</li></ol><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><h3 id="_1-程序计数器作用" tabindex="-1"><a class="header-anchor" href="#_1-程序计数器作用"><span>1. 程序计数器作用</span></a></h3><p>程序计数器就是在执行每条语句的时候记录下一条指令的地址,物理上是通过寄存器实现的</p><p><img src="https://s2.loli.net/2022/07/18/rEkPq1HKTMbc7Xf.png" alt="image-20220718102440409"></p><h3 id="_2-程序计数器特点" tabindex="-1"><a class="header-anchor" href="#_2-程序计数器特点"><span>2. 程序计数器特点</span></a></h3><ol><li>线程<strong>私有</strong>,每<strong>一个线程</strong>都有一个<strong>属于自己</strong>的<strong>独立计数器</strong></li><li>唯一一个<strong>不会出现内存溢出</strong>问题(Java虚拟机规范)</li></ol><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h2><h3 id="_1-虚拟机栈的定义" tabindex="-1"><a class="header-anchor" href="#_1-虚拟机栈的定义"><span>1. 虚拟机栈的定义</span></a></h3><ol><li>每一个<strong>线程运行时需要的内存空间</strong>,就是一个虚拟机栈</li><li>每个栈中有多个<strong>栈帧</strong>,代表<strong>每个方法所需要的内存</strong>,,栈帧进入时根据方法调用,如a方法中调用了b方法,那么a先进栈,b再进栈</li><li>每<strong>一个线程</strong>只能有<strong>一个活动栈帧</strong>,代表当前<strong>线程执行的方法</strong></li></ol><h3 id="_2-虚拟机栈相关问题" tabindex="-1"><a class="header-anchor" href="#_2-虚拟机栈相关问题"><span>2. 虚拟机栈相关问题</span></a></h3><h4 id="_1-垃圾回收是否涉及虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_1-垃圾回收是否涉及虚拟机栈"><span>1. 垃圾回收是否涉及虚拟机栈</span></a></h4><p>垃圾回收不涉及虚拟机栈,因为虚拟机栈总的方法每次<strong>出栈后自动回收</strong>了,不需要调用垃圾回收机制</p><h4 id="_2-虚拟机栈分配内存是不是越大越好" tabindex="-1"><a class="header-anchor" href="#_2-虚拟机栈分配内存是不是越大越好"><span>2. 虚拟机栈分配内存是不是越大越好</span></a></h4><p>不是,因为物理空间的大小是一定的,如果为一个线程分配很大的栈内存的话,那么其他的线程所能分配的内存就会变小,那么,<strong>线程就会变少.</strong></p><h4 id="_3-方法区中的局部变量会不会有线程安全问题" tabindex="-1"><a class="header-anchor" href="#_3-方法区中的局部变量会不会有线程安全问题"><span>3.方法区中的局部变量会不会有线程安全问题</span></a></h4><p>不会有线程安全问题,因为每一个线程使用独立的虚拟机栈,同时方法区中的局部变量<strong>不能逃离方法的作用范围</strong></p><h3 id="_3-线程诊断" tabindex="-1"><a class="header-anchor" href="#_3-线程诊断"><span>3.线程诊断</span></a></h3><h4 id="_1-cpu占用较高" tabindex="-1"><a class="header-anchor" href="#_1-cpu占用较高"><span>1. CPU占用较高</span></a></h4><p><a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=14&amp;spm_id_from=pageDriver&amp;vd_source=737bc72ddc8b0e9190302e61a877a9d8" target="_blank" rel="noopener noreferrer">JDK工具:jstack命令</a></p><h4 id="_2-无法得出结果" tabindex="-1"><a class="header-anchor" href="#_2-无法得出结果"><span>2. 无法得出结果</span></a></h4><p>比如进程死锁:<a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=15&amp;spm_id_from=pageDriver&amp;vd_source=737bc72ddc8b0e9190302e61a877a9d8" target="_blank" rel="noopener noreferrer">jstack命令</a></p><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h2><p>本地方法栈就是为<strong>本地方法</strong>分配一个内存空间,<strong>本地方法</strong>就是操作系统的方法,有C,C++实现,在Java代码中是<strong>native关键字</strong>修饰,比如:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><h3 id="_1-堆的定义" tabindex="-1"><a class="header-anchor" href="#_1-堆的定义"><span>1. 堆的定义</span></a></h3><p>每次<strong>创建对象</strong>都会使用堆内存,通过<strong>new</strong></p><h3 id="_2-堆的特点" tabindex="-1"><a class="header-anchor" href="#_2-堆的特点"><span>2. 堆的特点</span></a></h3><ul><li><strong>堆内存</strong>是<strong>线程共享</strong>的,所有要考虑线程安全问题</li><li>堆会使用<strong>垃圾回收机制</strong></li></ul><h3 id="_3-堆内存溢出" tabindex="-1"><a class="header-anchor" href="#_3-堆内存溢出"><span>3. 堆内存溢出</span></a></h3><p>例如:每次<strong>new</strong>一个对象,同时对象<strong>一直被引用</strong>,比如一直放在ArrayList当中,会造成堆内存占满,造成内存溢出</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> <span class="token class-name">Heap</span> space<span class="token comment">//堆内存溢出</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用<code>-Xmx8m</code>控制堆内存大小</p><h3 id="_4-堆内存诊断工具" tabindex="-1"><a class="header-anchor" href="#_4-堆内存诊断工具"><span>4. 堆内存诊断工具</span></a></h3><p><strong>jps,jmap,jconsole,jvirsualVM</strong></p><p><a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=19&amp;vd_source=737bc72ddc8b0e9190302e61a877a9d8" target="_blank" rel="noopener noreferrer">jmap等</a></p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h2><p><img src="https://s2.loli.net/2022/07/20/AFCWlf1k8hdVytq.png" alt="image-20220720161550163"></p><h3 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义"><span>1. 定义</span></a></h3><p>JVM 方法区. 方法区与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>,主要存储一些<strong>类的数据</strong>。</p><ul><li><strong>JDK1.8之前</strong>,把方法区称作<strong>永久代</strong></li><li><strong>JDK1.8之后</strong>,把方法区称作<strong>元空间</strong>,并把元空间放在<strong>本地内存中</strong>,方法区总的<strong>StringTable</strong>移到堆中.</li></ul><h3 id="_2-方法区的内存溢出问题" tabindex="-1"><a class="header-anchor" href="#_2-方法区的内存溢出问题"><span>2. 方法区的内存溢出问题</span></a></h3><p><img src="https://s2.loli.net/2022/07/20/dQpJtkZNwr1gf2W.png" alt="image-20220720162918437"></p><p><strong>结果</strong></p><p><img src="https://s2.loli.net/2022/07/20/KnqEAUbBro1xHWP.png" alt="image-20220720163005984">*</p><h3 id="_3-stringtable-字符串常量池" tabindex="-1"><a class="header-anchor" href="#_3-stringtable-字符串常量池"><span>3.StringTable 字符串常量池</span></a></h3><p><strong>存储的是指向String对象的索引</strong>，<strong>真实对象</strong>还是存储在<strong>堆中</strong></p>`,58)]))}const p=n(r,[["render",t]]),h=JSON.parse('{"path":"/202306%E7%A7%8B%E6%8B%9B%E5%87%86%E5%A4%87-%E6%97%A7/a-4JVM%E5%AD%A6%E4%B9%A0.html","title":"JVM学习","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"JVM概览","slug":"jvm概览","link":"#jvm概览","children":[{"level":3,"title":"1. JVM定义","slug":"_1-jvm定义","link":"#_1-jvm定义","children":[]},{"level":3,"title":"2. JVM好处","slug":"_2-jvm好处","link":"#_2-jvm好处","children":[]},{"level":3,"title":"3. JVM的组成","slug":"_3-jvm的组成","link":"#_3-jvm的组成","children":[]}]},{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[{"level":3,"title":"1. 程序计数器作用","slug":"_1-程序计数器作用","link":"#_1-程序计数器作用","children":[]},{"level":3,"title":"2. 程序计数器特点","slug":"_2-程序计数器特点","link":"#_2-程序计数器特点","children":[]}]},{"level":2,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[{"level":3,"title":"1. 虚拟机栈的定义","slug":"_1-虚拟机栈的定义","link":"#_1-虚拟机栈的定义","children":[]},{"level":3,"title":"2. 虚拟机栈相关问题","slug":"_2-虚拟机栈相关问题","link":"#_2-虚拟机栈相关问题","children":[]},{"level":3,"title":"3.线程诊断","slug":"_3-线程诊断","link":"#_3-线程诊断","children":[]}]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[{"level":3,"title":"1. 堆的定义","slug":"_1-堆的定义","link":"#_1-堆的定义","children":[]},{"level":3,"title":"2. 堆的特点","slug":"_2-堆的特点","link":"#_2-堆的特点","children":[]},{"level":3,"title":"3. 堆内存溢出","slug":"_3-堆内存溢出","link":"#_3-堆内存溢出","children":[]},{"level":3,"title":"4. 堆内存诊断工具","slug":"_4-堆内存诊断工具","link":"#_4-堆内存诊断工具","children":[]}]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[{"level":3,"title":"1. 定义","slug":"_1-定义","link":"#_1-定义","children":[]},{"level":3,"title":"2. 方法区的内存溢出问题","slug":"_2-方法区的内存溢出问题","link":"#_2-方法区的内存溢出问题","children":[]},{"level":3,"title":"3.StringTable 字符串常量池","slug":"_3-stringtable-字符串常量池","link":"#_3-stringtable-字符串常量池","children":[]}]}],"git":{"updatedTime":1751969860000,"contributors":[{"name":"Full","username":"Full","email":"2285288446@qq.com","commits":2,"url":"https://github.com/Full"}],"changelog":[{"hash":"d9f3e89ac0c7f9658e85d517b2e341155ebeb4a4","time":1751969860000,"email":"2285288446@qq.com","author":"Full","message":"构建修复"},{"hash":"46fbbb649a2b30164a6d253dd0f5cfcdf1657353","time":1751960301000,"email":"2285288446@qq.com","author":"Full","message":"第一次添加内容"}]},"filePathRelative":"202306秋招准备-旧/a-4JVM学习.md"}');export{p as comp,h as data};
